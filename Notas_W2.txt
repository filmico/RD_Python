Week 2:
=======

- Variables
  ----------

	a = 1   
	b = 'hola'

- Listas
  ------    

	a = [1,2,'joe']

- if
  --      

	if (x > 10):
		nnnnnn
  	elif (x = 10):
  		ooooooo
	else:
		jjjjjj

- Operators
  ---------

	== is equal to
	!= is not equal to
	> is greater than
	< is less than
	>= is greater than or equal to
	<= is less than or equal to

- Loops
  -----
  	lista = [1,2,'joe']

  	for item in lista:
  		print item

- Functions
  ---------

  	def myFunction(param1, param2 = 10):
  		print(param1 + param2)
  		result = param1 + param2
		return result

	a = myFunction(5, 6)
	print a

	Si param2 no se especifica, usa el valor default 10

- Builtin Functions
  -----------------

  len()
  -----
		fruit = [‘apple’, ‘orange’, ‘banana’, ‘kiwi’, ‘pear’]
		x = len(fruit)
		print x


  range()
  -------
	  myList = range(7)
	  print myList

	  >> [0, 1, 2, 3, 4, 5, 6]


- Methods
	Cuando usamos la notacion de punto en los datatypes propios como las variables, listas, diccionarios, etc estamos ingresando a los metodos
	Los metodos, se escriben con la misma notacion de las funciones aaa.bbb pero se llaman metodos para diferenciarlos de nuestras funciones

	lista = [10, 20, 30]
	lista.reverse()
	print lista

	‘the fat cat sat on the mat’.upper()
	‘the fat cat sat on the mat’.replace(‘cat’, ‘dog’)

	‘the fat cat sat on the mat’.split()
	>>  ['the', 'fat', 'cat', 'sat', 'on', 'the', 'mat'] 
	

- Modules
  -------
  Cada archivo .py representa un modulo y para poder usar sus Functions debemos importarlo en la cabecera de otro script

  script1.py

  En el segundo script y para usar las funciones de script1.py comenzariamos escribiendo

  import script1.py

  A su vez, para que esto funcione, Maya debe conocer la ruta de nuestros scripts utilizando lo que se explica a continuacion


   A Bit about Modules
   -------------------

	https://techartsurvival.blogspot.co.uk/2014/01/mayas-mildy-magical-modules.html

	a) Los Modulos son archivos .mod que le indican a Maya donde buscar los scripts. Si la carpeta modules no existe hay que crearla en alguna de las siguientes ubicaciones:

		1) C:\Program Files\Common Files\Autodesk Shared\Modules\Maya\2016\RiggingTool.mod   
			Para todos los usuarios que usen el maya 2016

		2) C:\Users\filmico\Documents\maya\modules\RiggingTool.mod   
			Solo para el usuario filmico

		3) C:\Users\filmico\Documents\maya\2016\modules\RiggingTool.mod
			Solo para el usuario filmico y maya 2016. 
			Se uso este en el curso

		Observamos que al final creamos un archivo llamado RiggingTools.mod
		Tambien observaremos mas adelante que si creamos un archivo llamado userSetup.py en la ruta a donde apunta el contenido del modulo, se carga ese archivo de python automaticamente

	b) El contenido tiene que ser el nombre del modulo la version y la ruta:   

		+ Rigging_Tool 1.0 C:\Rigging Dojo - Python 101 (On Demand)\RD_Python

	c) Agregamos una segunda linea con una variable de entorno

	    RIGGING_TOOL=C:\Rigging Dojo - Python 101 (On Demand)\RD_Python

	d) Agregamos una tercer linea para que maya agregue un path para los scripts

		scripts: C:\Rigging Dojo - Python 101 (On Demand)\RD_Python

	EL Archivo RiggingTool.mod deberia quedar asi:

		+ Rigging_Tool 1.0 C:\Rigging Dojo - Python 101 (On Demand)\RD_Python
		RIGGING_TOOL=C:\Rigging Dojo - Python 101 (On Demand)\RD_Python
		scripts: C:\Rigging Dojo - Python 101 (On Demand)\RD_Python	


	c) Crear la rutas C:\Rigging Dojo - Python 101 (On Demand)\RD_Python

	d) Crear un archivo userSetup.py de python que haga un print para verificar que funciona:

		print 'In Rig Tool'

	e) Verificar lanzando el Maya que lo primero que se carga en la consola es este modulo y realiza la impresion: In Rig Tool	

	f) Final Check

	# Check the module loads the path correctly

	import sys
	for s in sys.path:
		print s

	# Check were Maya look for modules	
	import os
	print os.environ['MAYA_MODULE_PATH']

	# if we need the module to be visible for all versions of maya, they must be placed here
	# C:\Users\filmico\Documents\maya\modules

	# if we need the module to be visible just for an specific Maya version, the must be places here
	# C:\Users\filmico\Documents\maya\2016\modules

	# Finally, check that maya knows were our modole lives. We call it by his name
	print os.environ['RIGGING_TOOL']

	The advantage of all this is that in our tool, we do not need to type the following each time:
		C:/Rigging Dojo - Python 101 (On Demand)/RD_Python

	Instead, we can add a new folder in the following way:
		os.environ['RIGGING_TOOL'] + '/rig'



	Con todo esto seteado, ya podemos usar import blabla.py y maya vera esos scripts que queremos importar de nuestro custom path  


	Funciones de los modulos importados
	-----------------------------------
	Supongamos que importamos el modulo primerScript.py y que este tiene una funcion llamada sumar
	Para realizar la suma escribiriamos

	import primerScript.py
	primerScript.sumar()

	o usar un alias as

	import primerScript.py as ps
	ps.sumar()	

	import maya.cmds as cmds
	cmds.sphere(r=10)

Crear y buscar elementos en maya con python
--------------------------------------------
	- Huesos en Mel
		joint -p -4.84587 0 8.902362 ;

	- Conversion a Python (Le agregamos un nombre)
		cmds.joint( n = 'Jnt01', p=[-4.84587, 0, 8.902362])

	- Buscar Posicion de Hueso con Python
		cmds.joint( 'Jnt01', p=True, q=True)

	- Mover el hueso de posicion
		cmds.joint( 'Jnt01', p=[0, 0, 0], e=True)

Listar elementos
----------------

	El comando ls tiene muchisimo parametros para listar seleciones por tipo, por UUID, etc

	# list all objects
	cmds.ls()

	# List all selected objects
	cmds.ls( selection=True )

	# Find a node by UUID
	cmds.ls( 'C2BB8B0D-4B5B-FC00-017A-1D85C39AC3AE' )
	# Result: [u'ikj_hip'] #

	# Return a node's UUID
	cmds.ls( 'persp', uuid=True )

	# List all nodes below the selected node
	cmds.ls( dag=True, ap=True, sl=True )

	import maya.cmds as cmds
	# Find a node by UUID
	cmds.ls( 'C2BB8B0D-4B5B-FC00-017A-1D85C39AC3AE' )
	# Result: [u'ikj_hip'] #

	# When trying to find a list of all objects of a specific
	# type, one approach might be to list all objects and then
	# use the nodeType command to then filter the list. As in:
	
	allObjects = cmds.ls(l=True)
	for obj in allObjects:
	   if cmds.nodeType(obj) == 'surfaceShape':
	     print obj

	# The problem with this is that 'nodeType' returns the
	# most derived type of the node. In this example, "surfaceShape"
	# is a base type for nurbsSurface so nothing will be printed.
	# To do this properly, the -typ/type flag should be used
	# to list objects of a specific type as in:
	
	allObjects = cmds.ls(type='surfaceShape')
	for obj in allObjects:
	    print obj

	# Return a node's UUID
	cmds.ls( 'persp', uuid=True )


Renombrar
---------
	myNode = mc.rename(myNode, ‘newNodeName’)

Agrupar
-------
	#group the locator
	mc.group(‘locator1’)

	#create an empty group
	myNull = mc.group(empty=True, name=’transformNode’)	

Locator
-------
	loc = mc.spaceLocator(name=’myLocator’)

Duplicate	
---------
	newLocator = mc.duplicate(‘locator1’, name=’myNewLocator’)

Object Exist
------------
	if mc.objExists(‘locator7’):
   		mc.rename(‘locator7’, ‘myLocator’)


Delete
------
	mc.delete(‘locator1’)

SettAttr
--------
	mc.setAttr(‘locator1.translateX’, 10.2)
	#lock and hide an attribute
	mc.setAttr(‘locator1.translateX’, lock=True, keyable=False)

GetAttr
-------
	tx = mc.getAttr(‘locator1.translateX’)
	print tx	

AddAttr
-------
	mc.addAttr('locator1', longName='ikSwitch', attributeType='double', min=0, max=1)

Parent
------	
	mc.parent(‘locator1’, ‘locator2’)
	mc.parent(‘locator1’, world=True)

ListRelatives
-------------
	#get the parent
		mc.listRelatives(‘locator1’, parent=True)

	#get the child
		mc.listRelatives(‘locator1’, children=True)

	#get all childrens
		cmds.listRelatives('ikj_hip', ad=True)

	#list all descendents, the whole hierarchy below
		mc.listRelatives(‘locator1’, allDescendents)	


ConnectAttr
-----------
	mc.connectAttr(‘locator1.translateX’, ‘locator2.translateY’)	

Lisar Concexiones
-----------------

	#list all connections to all attributes, in and out

	mc.listConnections(‘locator1’)

	#list incoming connections driving tx
	mc.listConnections(‘locator1.translateX’, source=True, destination=False)

	#list outgoing connections that translateX is driving

	mc.listConnections(‘locator1.translateX’, source=False, destination=True)

IK Handle
---------
	mc.ikHandle(startJoint=’joint1’, endEffector=’joint3’, solver=’ikRPsolver’)


Constraints
-----------
	mc.pointConstraint(‘locator2’, ‘locator1’)
	orientConstraint: Pretty much the same
	parentConstraint: Pretty much the same	



Ver los ejemplos de \RD_Python\000_Ger_Test\W2